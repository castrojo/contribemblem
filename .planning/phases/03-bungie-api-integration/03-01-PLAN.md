---
phase: 03-bungie-api-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/select-emblem.sh
  - scripts/fetch-emblem.sh
  - data/emblem-config.json
  - .github/workflows/update-emblem.yml
autonomous: true

user_setup:
  - service: bungie-api
    why: "Fetch Destiny 2 emblem artwork for badge backgrounds"
    env_vars:
      - name: BUNGIE_API_KEY
        source: "Create developer account at https://www.bungie.net/en/Application → Register new application → Copy API Key"
    account_setup:
      - task: "Create Bungie.net developer account"
        url: "https://www.bungie.net/en/Application"
      - task: "Register application to get API key"
        details: "Application name: ContribEmblem, OAuth not required (read-only public data)"

must_haves:
  truths:
    - "Action selects same emblem consistently throughout each week"
    - "Action downloads emblem image from Bungie API successfully"
    - "Emblem selection changes on Sunday (week boundary)"
    - "Fallback emblem used when Bungie API fails"
  artifacts:
    - path: "scripts/select-emblem.sh"
      provides: "ISO week-based deterministic emblem selection"
      min_lines: 40
    - path: "scripts/fetch-emblem.sh"
      provides: "Bungie API HTTP client with authentication"
      min_lines: 50
    - path: "data/emblem-config.json"
      provides: "Emblem rotation list and fallback configuration"
      contains: "rotation"
    - path: ".github/workflows/update-emblem.yml"
      provides: "Emblem fetching workflow steps"
      contains: "BUNGIE_API_KEY"
  key_links:
    - from: ".github/workflows/update-emblem.yml"
      to: "scripts/select-emblem.sh"
      via: "workflow step execution"
      pattern: "\\./scripts/select-emblem\\.sh"
    - from: "scripts/select-emblem.sh"
      to: "data/emblem-config.json"
      via: "jq reads rotation array"
      pattern: "jq.*emblem-config\\.json"
    - from: "scripts/fetch-emblem.sh"
      to: "bungie.net API"
      via: "curl with X-API-Key header"
      pattern: "X-API-Key.*BUNGIE_API_KEY"
---

<objective>
Implement weekly emblem rotation with Bungie API integration for badge background artwork

Purpose: Enable automatic Destiny 2-style emblem artwork that rotates weekly, completing the data pipeline before image generation in Phase 4
Output: Bash scripts for deterministic emblem selection and Bungie API fetching, integrated into workflow
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-github-actions-foundation/01-01-SUMMARY.md
@.planning/phases/02-github-stats-collection/02-01-SUMMARY.md
@.planning/phases/03-bungie-api-integration/03-RESEARCH.md

# Existing workflow and script patterns
@.github/workflows/update-emblem.yml
@scripts/fetch-stats.sh
@scripts/process-stats.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deterministic weekly emblem selector</name>
  <files>
scripts/select-emblem.sh
data/emblem-config.json
  </files>
  <action>
Create `scripts/select-emblem.sh` implementing ISO week-based seeded selection:

1. Read emblem rotation list from `data/emblem-config.json`
2. Calculate current ISO week number using UTC date (matches Sunday schedule from Phase 1)
3. Generate deterministic seed from year + week (format: "2026-W04")
4. Hash seed using `sha256sum` to get deterministic random value
5. Select emblem from rotation array using modulo: `hash_value % array_length`
6. Output selected emblem hash to stdout for piping to fetch script
7. If rotation array empty or config missing, output fallback emblem hash (1409726931 - "The Seventh Column" emblem from research)

Create `data/emblem-config.json` with structure:
```json
{
  "rotation": [
    1409726931,
    2448092419,
    3642894792
  ],
  "fallback": 1409726931
}
```

**Why bash not Node.js:** Match existing script pattern (fetch-stats.sh, process-stats.sh are bash). ISO week calculation available via `date` command.

**ISO week algorithm:** Use `date -u +%G-W%V` (GNU date with %G for ISO year, %V for ISO week). This handles year boundaries correctly (week 1 contains first Thursday).

**Seeded randomness:** `echo -n "$seed" | sha256sum | cut -c1-8` produces 8 hex chars, convert to decimal with `printf '%d' 0x...`, then modulo array length.

**Critical:** Use UTC date (`date -u`) to match Phase 1 Sunday midnight UTC schedule. Prevents emblem changing mid-week due to timezone differences.
  </action>
  <verify>
Test deterministic selection:
```bash
chmod +x scripts/select-emblem.sh

# Test same week produces same output
OUTPUT1=$(./scripts/select-emblem.sh)
OUTPUT2=$(./scripts/select-emblem.sh)
test "$OUTPUT1" = "$OUTPUT2" && echo "✓ Deterministic selection working"

# Verify output is numeric emblem hash
echo "$OUTPUT1" | grep -qE '^[0-9]+$' && echo "✓ Valid emblem hash format"

# Test fallback when config missing
mv data/emblem-config.json data/emblem-config.json.bak
FALLBACK=$(./scripts/select-emblem.sh)
test "$FALLBACK" = "1409726931" && echo "✓ Fallback emblem working"
mv data/emblem-config.json.bak data/emblem-config.json
```
  </verify>
  <done>
- `scripts/select-emblem.sh` exists and is executable
- `data/emblem-config.json` exists with rotation array and fallback
- Script outputs same emblem hash when run multiple times in same week
- Script outputs fallback emblem (1409726931) when config missing
- Script uses UTC date for ISO week calculation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Bungie API emblem fetcher</name>
  <files>
scripts/fetch-emblem.sh
  </files>
  <action>
Create `scripts/fetch-emblem.sh` that accepts emblem hash via stdin and downloads artwork:

1. Read emblem hash from stdin (piped from select-emblem.sh)
2. Fetch Bungie Manifest version to get current database URL:
   ```bash
   curl -H "X-API-Key: $BUNGIE_API_KEY" \
        https://www.bungie.net/Platform/Destiny2/Manifest/
   ```
3. Extract DestinyInventoryItemDefinition URL from response using `jq`:
   ```
   .Response.jsonWorldComponentContentPaths.en.DestinyInventoryItemDefinition
   ```
4. Download manifest database (if not cached - cache check in workflow, Task 3)
5. Look up emblem hash in manifest JSON using `jq .[$hash]`
6. Extract icon path from `.displayProperties.icon`
7. Download emblem image from `https://www.bungie.net{iconPath}` to `data/emblem.jpg`
8. **Error handling:**
   - If API returns non-200 status: log error, exit with code 1 (workflow will use fallback)
   - If emblem hash not in manifest: log warning, exit with code 1
   - If BUNGIE_API_KEY not set: log error message about user setup, exit 1
   - On error exit, workflow should use fallback emblem (handled in Task 3)

**Bungie API response format (from RESEARCH.md):**
- All responses wrapped in `{ Response, ErrorCode, ErrorStatus }`
- ErrorCode === 1 means success, other codes are errors
- Always check ErrorCode in response body, not just HTTP status

**Rate limiting (from RESEARCH.md):**
- Log rate limit remaining from response headers (non-blocking, like Phase 2)
- Pattern: `X-RateLimit-Remaining` header monitoring
- Weekly schedule + caching keeps us well under 25 req/sec, 250 req/hour limits

**Why not TypeScript/Node.js:** Maintain consistency with bash-based scripts from Phase 2. Bungie API is RESTful JSON - bash + curl + jq is sufficient.

**Critical:** Include `User-Agent` header (required by Bungie API best practices): `User-Agent: ContribEmblem/1.0 (+https://github.com/castrojo/contribemblem)`
  </action>
  <verify>
Test emblem fetching with real API (requires BUNGIE_API_KEY):
```bash
chmod +x scripts/fetch-emblem.sh

# Test with known emblem hash
export BUNGIE_API_KEY="your-api-key-here"
echo "1409726931" | ./scripts/fetch-emblem.sh

# Verify emblem image downloaded
test -f data/emblem.jpg && echo "✓ Emblem image downloaded"
file data/emblem.jpg | grep -q "JPEG\|PNG" && echo "✓ Valid image format"

# Test error handling - invalid emblem hash
echo "999999999" | ./scripts/fetch-emblem.sh
test $? -eq 1 && echo "✓ Error handling working"

# Test missing API key
unset BUNGIE_API_KEY
echo "1409726931" | ./scripts/fetch-emblem.sh 2>&1 | grep -q "BUNGIE_API_KEY" && echo "✓ Missing API key error message"
```
  </verify>
  <done>
- `scripts/fetch-emblem.sh` exists and is executable
- Script accepts emblem hash via stdin
- Script downloads emblem image to `data/emblem.jpg`
- Script checks Bungie API ErrorCode field in response body
- Script exits with code 1 on errors (API failure, invalid hash, missing key)
- Script includes User-Agent header in API requests
- Script logs rate limit remaining (non-blocking monitoring)
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate emblem fetching into workflow</name>
  <files>
.github/workflows/update-emblem.yml
  </files>
  <action>
Update `.github/workflows/update-emblem.yml` to add emblem fetching steps after stats collection:

Add after "Log stats status" step:

1. **Cache Bungie Manifest** (similar to stats cache pattern):
   ```yaml
   - name: Cache Bungie Manifest
     id: cache-manifest
     uses: actions/cache@v4
     with:
       path: data/manifest.json
       key: bungie-manifest-${{ steps.get-date.outputs.date }}
       restore-keys: |
         bungie-manifest-
   ```
   *Why date-based key:* Manifest updates infrequently (every 3 months), but checking daily is safe. Cache size ~100MB.

2. **Create emblem config if missing** (first-time setup):
   ```yaml
   - name: Create default emblem config
     run: |
       if [ ! -f data/emblem-config.json ]; then
         echo '{"rotation":[1409726931,2448092419,3642894792],"fallback":1409726931}' > data/emblem-config.json
       fi
   ```

3. **Select weekly emblem**:
   ```yaml
   - name: Select weekly emblem
     id: select-emblem
     run: |
       chmod +x scripts/select-emblem.sh
       EMBLEM_HASH=$(./scripts/select-emblem.sh)
       echo "hash=$EMBLEM_HASH" >> $GITHUB_OUTPUT
       echo "Selected emblem hash: $EMBLEM_HASH"
   ```

4. **Fetch emblem artwork**:
   ```yaml
   - name: Fetch emblem from Bungie API
     run: |
       chmod +x scripts/fetch-emblem.sh
       echo "${{ steps.select-emblem.outputs.hash }}" | ./scripts/fetch-emblem.sh || {
         echo "⚠️  Bungie API fetch failed, using fallback emblem"
         # Download fallback emblem directly (skip API)
         curl -o data/emblem.jpg https://www.bungie.net/common/destiny2_content/icons/[fallback-path].jpg
       }
     env:
       BUNGIE_API_KEY: ${{ secrets.BUNGIE_API_KEY }}
   ```

5. **Log emblem status**:
   ```yaml
   - name: Log emblem status
     run: |
       echo "✓ Emblem image ready for Phase 4 image generation"
       ls -lh data/emblem.jpg
       file data/emblem.jpg
   ```

**Secrets setup note:** User must add BUNGIE_API_KEY to repository secrets (GitHub Settings → Secrets and variables → Actions → New repository secret). This is documented in user_setup frontmatter.

**Fallback strategy:** If fetch-emblem.sh exits with code 1, use `curl` to download The Seventh Column emblem directly (hard-coded fallback path). This ensures workflow never fails due to Bungie API issues.

**Integration with Phase 1 decisions:**
- Uses existing git config and loop prevention
- Conditional commit logic (from Phase 1) still applies
- [skip ci] message already configured

**Integration with Phase 2 patterns:**
- Follows cache key pattern (date-based)
- Similar conditional execution (cache-hit checks)
- Non-blocking error handling (log warnings, don't fail)
  </action>
  <verify>
Test workflow integration:
```bash
# Validate YAML syntax
cat .github/workflows/update-emblem.yml | grep -q "BUNGIE_API_KEY" && echo "✓ API key configured"
cat .github/workflows/update-emblem.yml | grep -q "select-emblem.sh" && echo "✓ Selection step present"
cat .github/workflows/update-emblem.yml | grep -q "fetch-emblem.sh" && echo "✓ Fetch step present"
cat .github/workflows/update-emblem.yml | grep -q "bungie-manifest" && echo "✓ Manifest cache present"

# Dry-run workflow locally (requires act or manual trigger)
# User will test this in checkpoint after automation completes
```
  </verify>
  <done>
- Workflow includes manifest caching step with date-based key
- Workflow creates default emblem config if missing
- Workflow executes select-emblem.sh and captures output
- Workflow executes fetch-emblem.sh with BUNGIE_API_KEY from secrets
- Workflow implements fallback emblem download on fetch failure
- Workflow logs emblem status after fetching
- BUNGIE_API_KEY referenced from secrets (user setup required)
  </done>
</task>

</tasks>

<verification>
**Phase 3 requirements coverage:**

- [ ] EMBLM-01: Action fetches emblem artwork from Bungie API with proper authentication
  - ✓ Task 2 creates fetch-emblem.sh with X-API-Key header
  - ✓ Task 3 integrates with BUNGIE_API_KEY secret

- [ ] EMBLM-02: Action randomly selects one emblem from user's rotation list weekly
  - ✓ Task 1 creates select-emblem.sh with rotation array
  - ✓ Task 3 executes selection in workflow

- [ ] EMBLM-03: Random selection seeded by week number for consistency within week
  - ✓ Task 1 uses ISO week + sha256 hash for deterministic selection
  - ✓ UTC date ensures consistency with Sunday schedule

- [ ] EMBLM-04: Fallback emblem used if fetch fails or emblem ID invalid
  - ✓ Task 1 returns fallback when config missing
  - ✓ Task 2 exits with error code on API failure
  - ✓ Task 3 catches failure and downloads fallback emblem

**Integration checks:**
- [ ] Scripts follow Phase 2 bash patterns (fetch/process separation)
- [ ] Caching follows Phase 2 date-based key pattern
- [ ] Error handling follows Phase 2 non-blocking pattern
- [ ] Git config and loop prevention from Phase 1 still apply

**Output verification:**
```bash
# After plan execution
ls -l scripts/select-emblem.sh scripts/fetch-emblem.sh
cat data/emblem-config.json
grep -A5 "Bungie" .github/workflows/update-emblem.yml
```
</verification>

<success_criteria>
**Phase 3 complete when:**

1. ✓ Action selects same emblem consistently throughout each week (deterministic selection)
2. ✓ Action downloads emblem image from Bungie API successfully (fetch-emblem.sh works)
3. ✓ Emblem selection changes on Sunday midnight UTC (week boundary in ISO calculation)
4. ✓ Fallback emblem used when Bungie API fails (error handling in workflow)
5. ✓ Scripts follow existing bash patterns from Phase 2
6. ✓ Caching prevents redundant manifest downloads (actions/cache@v4)
7. ✓ User setup documented for BUNGIE_API_KEY repository secret

**Ready for Phase 4 (Image Generation):**
- `data/stats.json` available from Phase 2
- `data/emblem.jpg` available from Phase 3
- Both data sources ready for composite image generation
</success_criteria>

<output>
After completion, create `.planning/phases/03-bungie-api-integration/03-01-SUMMARY.md`
</output>
